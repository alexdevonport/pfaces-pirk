/*
* pirk.cpu.cl
*
*  date    : 04.07.2019
*  author  : A. Devonport | Electrical Engineering and Computer Sciences, Univeristy of California, Berkeley
*  about   : An OpenCL kernel for computing interval overapproximations of reachable sets.
* ***********************************************************************
*  The kernel manager will replace parameters enclosed by "@@" before compiling !
*/

#define CPU_VERSION

/* includes for the growth bound method */
// /home/hcs/Documents/pFaces/examples/pirk/ex_n_link/hi.cl

/* common utility file */

#include "/home/hcs/Documents/pFaces/examples/pirk/ex_n_link/dynamics.cl"
#include "/home/hcs/Documents/pFaces/examples/pirk/ex_n_link/bounds.cl"

#include "/home/hcs/Documents/pFaces/examples/pirk/ex_n_link/growth_bound_matrix.cl"

float growth_bound_radius_dynamics(__global float* r, __global float* u, float t, int i)
{
  float dr=0;
  for (int j=0; j < 1000; j++) {
    dr += growth_bound_matrix(i,j,u)*r[j];
  }
  dr += u[i]; //this is causing the bug
  return dr;
}


__kernel void gb_initialize_center( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
  float x_low, x_up, u_low, u_up;
  int i = get_global_id(0);
  x_low = initial_state_lower_bound(i);
  x_up = initial_state_upper_bound(i);
  u_low = input_lower_bound(i);
  u_up = input_upper_bound(i);
  /* for the center dynamics, we want the initial state to be the center of the interval 
   * (hence the name), that is the mean of the upper and lower bound. */
  initial_state[i] = 0.5 * (x_low + x_up);
  final_state[i] = initial_state[i];
  k0[i] = 0;
  k1[i] = 0;
  k2[i] = 0;
  k3[i] = 0;
  tmp[i] = 0;
  input[i]=0.5 * (u_up + u_low);
  *t = 0.000000;

}


#define step_size 0.100000
#define RK4_NINT 5
#define RK4_H ((0.100000/RK4_NINT))

#define gb_integrate_dynchoice_1 gb_integrate_center_1
#define gb_integrate_dynchoice_2 gb_integrate_center_2
#define gb_integrate_dynchoice_3 gb_integrate_center_3
#define gb_integrate_dynchoice_4 gb_integrate_center_4
#define gb_integrate_dynchoice_5 gb_integrate_center_5
#define gb_integrate_dynchoice_6 gb_integrate_center_6
#define gb_integrate_dynchoice_7 gb_integrate_center_7
#define gb_integrate_dynchoice_8 gb_integrate_center_8

#define dynfn dynamics_element

#include "growth_bound/integrate_kfns.cl"

__kernel void gb_initialize_radius( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
  float x_low, x_up, u_low, u_up;
  int i = get_global_id(0);
  x_low = initial_state_lower_bound(i);
  x_up = initial_state_upper_bound(i);
  u_low = input_lower_bound(i);
  u_up = input_upper_bound(i);
  /* for the radius dynamics, we want the initial state to be the radius of the interval 
   * (hence the name), that is one-half the distance between the upper and lower bound. */
  initial_state[i] = 0.5 * (x_up - x_low);
  final_state[i] = initial_state[i];
  k0[i] = 0;
  k1[i] = 0;
  k2[i] = 0;
  k3[i] = 0;
  tmp[i] = 0;
  input[i]=0.5 * (u_up - u_low);
  printf("%f\n",input[i]);
  *t = 0.000000;

}

#undef gb_integrate_dynchoice_1
#undef gb_integrate_dynchoice_2
#undef gb_integrate_dynchoice_3
#undef gb_integrate_dynchoice_4
#undef gb_integrate_dynchoice_5
#undef gb_integrate_dynchoice_6
#undef gb_integrate_dynchoice_7
#undef gb_integrate_dynchoice_8

#undef dynfn

#define gb_integrate_dynchoice_1 gb_integrate_radius_1
#define gb_integrate_dynchoice_2 gb_integrate_radius_2
#define gb_integrate_dynchoice_3 gb_integrate_radius_3
#define gb_integrate_dynchoice_4 gb_integrate_radius_4
#define gb_integrate_dynchoice_5 gb_integrate_radius_5
#define gb_integrate_dynchoice_6 gb_integrate_radius_6
#define gb_integrate_dynchoice_7 gb_integrate_radius_7
#define gb_integrate_dynchoice_8 gb_integrate_radius_8
#define dynfn growth_bound_radius_dynamics

#include "growth_bound/integrate_kfns.cl"